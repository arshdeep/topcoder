http://graphics.stanford.edu/~seander/bithacks.html
Compute the minimum (min) or maximum (max) of two integers without branching
r = y ^ ((x ^ y) & -(x < y)); // min(x, y)
r = x ^ ((x ^ y) & -(x < y)); // max(x, y)
--
Determining if an integer is a power of 2
f = v && !(v & (v - 1));
--
Conditionally set or clear bits without branching
bool f;         // conditional flag
unsigned int m; // the bit mask
unsigned int w; // the word to modify:  if (f) w |= m; else w &= ~m; 

w ^= (-f ^ w) & m;
--
Conditionally negate a value without branching
If you need to negate only when a flag is false, then use the following to avoid branching:
bool fDontNegate;  // Flag indicating we should not negate v.
int v;             // Input value to negate if fDontNegate is false.
int r;             // result = fDontNegate ? v : -v;

r = (fDontNegate ^ (fDontNegate - 1)) * v;
If you need to negate only when a flag is true, then use this:
bool fNegate;  // Flag indicating if we should negate v.
int v;         // Input value to negate if fNegate is true.
int r;         // result = fNegate ? -v : v;

r = (v ^ -fNegate) + fNegate;
--
Swapping values with XOR
#define SWAP(a, b) (((a) ^= (b)), ((b) ^= (a)), ((a) ^= (b)))
--
Thus the following pseudocode prints all the subsets of a given set ( this set is known as a power set )
 
start
    A[ 0..n-1 ] //set of n-elements
    for i := 0 to 2n
        print “subset no. i”
        for j := 0 to n
            if j-th bit is set in i
                print A[j]    
        end for
        print “\n”
    end for
end

-----

Generating all subsets of a subset.
Consider a number 10110
The following numbers are subsets of this number
00000
00010
00100
00110
10000
10010
10100
10110
Now there's a nice and short way of generating them as shown below:
start
    N; //an integer
    X = N
    while true
        print X
        if( X == 0 )
            break;
        X = (X-1) & N;
    end while
end
